/* SQL Advanced Data Analytics Project 
 Tasks included in the project: Database Setup
                                Change over time analysis
                                Cumulative Analysis
                                Performance Analysis
                                Data Segementation Analysis
                                Part to whole (Proportional Analysis)
                                Reporting

-- First of all , we have to create schema and Tables in our database */

-- Create schema 
CREATE SCHEMA gold;

-- Create the tables 
CREATE TABLE gold.dim_customers(
	customer_key int,
	customer_id int,
	customer_number varchar(50),
	first_name varchar(50),
	last_name varchar(50),
	country varchar(50),
	marital_status varchar(50),
	gender varchar(50),
	birthdate date,
	create_date date
);

CREATE TABLE gold.dim_products(
	product_key int ,
	product_id int ,
	product_number varchar(50) ,
	product_name varchar(50) ,
	category_id varchar(50) ,
	category varchar(50) ,
	subcategory varchar(50) ,
	maintenance varchar(50) ,
	cost int,
	product_line varchar(50),
	start_date date 
);

CREATE TABLE gold.fact_sales(
	order_number varchar(50),
	product_key int,
	customer_key int,
	order_date date,
	shipping_date date,
	due_date date,
	sales_amount int,
	quantity smallint,
	price int 
);

-- Now , import data in all of the created tables 
-- You can import data by using the import command or by writing the code 

\copy gold.dim_customers
FROM 'C:\Users\TALAL BIN ZAHID\Downloads\gold.dim_customers.csv'
DELIMITER ','
CSV HEADER
NULL '';

\copy gold.dim_products
FROM 'C:\Users\TALAL BIN ZAHID\Downloads\gold.dim_products.csv'
DELIMITER ','
CSV HEADER
NULL '';

\copy gold.fact_sales
FROM 'C:\Users\TALAL BIN ZAHID\Downloads\gold.fact_sales.csv'
DELIMITER ','
CSV HEADER
NULL '';

/* Now , the data is imported so we would start the analysis

 Change over Time analysis 
 Purpose:
   - To track trends, growth, and changes in key metrics over time.
   - For time-series analysis and identifying seasonality.
   - To measure growth or decline over specific periods.

 SQL Functions Used:
    - Date Functions: DATEPART(), DATETRUNC(), FORMAT()
    - Aggregate Functions: SUM(), COUNT(), AVG() */

-- Sales performance over time 
select order_date , sales_amount from gold.fact_sales
where order_date is not null
order by order_date ;

-- sum of total sales in a day 
select order_date , SUM(sales_amount) from gold.fact_sales
where order_date is not null
group by order_date
order by order_date ;

-- total sales , customers and quantity in a month
SELECT EXTRACT(Month FROM order_date) AS order_month, SUM(sales_amount) AS total_sales ,
Count (Distinct customer_key ) , SUM(quantity) as total_quantity FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY order_month
ORDER BY order_month;

-- total sales , customers and quantity in a year 
SELECT EXTRACT(YEAR FROM order_date) AS order_year,
EXTRACT(Month FROM order_date) AS order_month ,
SUM(sales_amount) AS total_sales ,
Count (Distinct customer_key ) ,
SUM(quantity) as total_quantity FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY order_year , order_month
ORDER BY order_year , order_month ;

-- Date_trunc
SELECT  DATE_TRUNC('month', order_date) AS order_month,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT customer_key) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY order_month
ORDER BY order_month;

-- Format 
SELECT  TO_CHAR(order_date, 'YYYY-Mon') AS order_month,
SUM(sales_amount) AS total_sales,
COUNT(DISTINCT customer_key) AS total_customers,
SUM(quantity) AS total_quantity
FROM gold.fact_sales
WHERE order_date IS NOT NULL
GROUP BY TO_CHAR(order_date, 'YYYY-Mon')
ORDER BY TO_CHAR(order_date, 'YYYY-Mon');

/* Cumulative Analysis 
 Purpose:
    - To calculate running totals or moving averages for key metrics.
    - To track performance over time cumulatively.
    - Useful for growth analysis or identifying long-term trends.

 SQL Functions Used:
    - Window Functions: SUM() OVER(), AVG() OVER() */

-- Calculate the total sales per month 
-- The cummulative total of sales over time

Select DATE_TRUNC('month', order_date) AS order_month,
SUM(sales_amount) as total_sales 
from gold.fact_sales
where order_date is not null
group by order_month
order by order_month;

-- Cummulative Total Sales 
select order_month , total_sales ,
SUM (total_sales) over (order by order_month) as cummulative_total_sales
from
(
Select DATE_TRUNC('month', order_date) AS order_month,
SUM(sales_amount) as total_sales 
from gold.fact_sales
where order_date is not null
group by order_month
) ;

-- Cummulative Total Sales for each year
select order_month , total_sales ,
SUM (total_sales) over ( Partition by order_month order by order_month) as cummulative_total_sales
from
(
Select DATE_TRUNC('month', order_date) AS order_month,
SUM(sales_amount) as total_sales 
from gold.fact_sales
where order_date is not null
group by order_month
) ;

-- Moving average of the price
select order_month , total_sales ,
SUM (total_sales) over (order by order_month) as cummulative_total_sales ,
Round(AVG(avg_price) over (order by order_month),0) as moving_average_price
from
(
Select DATE_TRUNC('month', order_date) AS order_month,
SUM(sales_amount) as total_sales ,
AVG (price) as avg_price
from gold.fact_sales
where order_date is not null
group by order_month
) ;

/* Performance Analysis (year on year , month on month)
 Purpose:
    - To measure the performance of products, customers, or regions over time.
    - For benchmarking and identifying high-performing entities.
    - To track yearly trends and growth.

 SQL Functions Used:
    - LAG(): Accesses data from previous rows.
    - AVG() OVER(): Computes average values within partitions.
    - CASE: Defines conditional logic for trend analysis. */

-- Analyze the yearly performance of products by comparing their sales 
-- Both the average sales performance of the product and the previous year's sales 

with yearly_product as (
select extract ( year from f.order_date) as order_year ,
p.product_name , Sum(f.sales_amount) As current_sales
from gold.fact_sales f 
left join gold.dim_products p 
on f.product_key = p.product_key 
where f.order_date is not null 
group by order_year , p.product_name 
)
select order_year, product_name , current_sales,
round (Avg(current_sales) over (Partition By product_name ),2) as avg_sales ,
current_sales - round (Avg(current_sales) over (Partition By product_name ),2)
as diff_avg
from yearly_product ;

-- Categorizing the sales by case statement 
with yearly_product as (
select extract ( year from f.order_date) as order_year ,
p.product_name , Sum(f.sales_amount) As current_sales
from gold.fact_sales f 
left join gold.dim_products p 
on f.product_key = p.product_key 
where f.order_date is not null 
group by order_year , p.product_name 
)
select order_year, product_name , current_sales,
round (Avg(current_sales) over (Partition By product_name ),2) as avg_sales ,
current_sales - round (Avg(current_sales) over (Partition By product_name ),2)
as diff_avg, 
Case when current_sales - round (Avg(current_sales) over (Partition By product_name ),2)
     > 0 Then 'Above Avg'
	 when current_sales - round (Avg(current_sales) over (Partition By product_name ),2)
	 < 0 Then 'Below Avg'
	 else 'Avg'
End avg_change ,
-- year on year analysis 
Lag (current_sales) over (Partition By product_name order by order_year) py_sales,
current_sales - Lag (current_sales) over (Partition By product_name order by order_year) diff_py ,
case when current_sales - Lag (current_sales) over (Partition By product_name order by order_year) 
     > 0 then 'Increase'
	 when current_sales - Lag (current_sales) over (Partition By product_name order by order_year) 
     < 0 then 'Decrease'
	 else 'No change'
End py_change 
from yearly_product 
order by product_name , order_year;

/* Part to Whole Analysis 
 Purpose:
    - To compare performance or metrics across dimensions or time periods.
    - To evaluate differences between categories.
    - Useful for A/B testing or regional comparisons.

SQL Functions Used:
    - SUM(), AVG(): Aggregates values for comparison.
    - Window Functions: SUM() OVER() for total calculations. 
*/ 

-- which categories contribute the most to overall sales 
select category , SUM(sales_amount) total_sales 
from gold.fact_sales f
left join gold.dim_products p
on p.product_key = f.product_key 
group  by category ;

-- categorizing the business by percentages
WITH category_sales AS (
  SELECT 
    category, 
    SUM(sales_amount) AS total_sales 
  FROM gold.fact_sales f
  LEFT JOIN gold.dim_products p
    ON p.product_key = f.product_key 
  GROUP BY category
)
SELECT 
  category, 
  total_sales, 
  SUM(total_sales) OVER() AS overall_sales,
  concat(ROUND((CAST(total_sales AS numeric) / SUM(total_sales) OVER()) * 100, 2) , '%' )
    AS percentage_of_total
FROM category_sales;

/* Data Segmentation Analysis

Purpose:
    - To group data into meaningful categories for targeted insights.
    - For customer segmentation, product categorization, or regional analysis.

SQL Functions Used:
    - CASE: Defines custom segmentation logic.
    - GROUP BY: Groups data into segments. 
*/

/* Segment products into cost ranges and 
count how many products fall into each segment */

select product_key , product_name , cost , 
case when cost < 100 then 'Below 100'
     when cost between 100 and 500 then '100-500'
	 when cost between 500 and 1000 then '500-1000'
     else 'Above 1000'
end cost_range 
from gold.dim_products ;

-- number of products in a specific range 
with product_segments as (
select product_key , product_name , cost , 
case when cost < 100 then 'Below 100'
     when cost between 100 and 500 then '100-500'
	 when cost between 500 and 1000 then '500-1000'
     else 'Above 1000'
end cost_range 
from gold.dim_products
)
select cost_range , count(product_key) as total_products 
from product_segments 
group by cost_range
order by total_products DESC;

/*Group customers into three segments based on their spending behavior:
	- VIP: Customers with at least 12 months of history and spending more than €5,000.
	- Regular: Customers with at least 12 months of history but spending €5,000 or less.
	- New: Customers with a lifespan less than 12 months.
And find the total number of customers by each group
*/

With customer_spending as (
SELECT 
  c.customer_key, 
  SUM(f.sales_amount) AS total_spending, 
  MIN(order_date) AS first_order,
  MAX(order_date) AS last_order,
  (DATE_PART('year', AGE(MAX(order_date), MIN(order_date))) * 12 +
   DATE_PART('month', AGE(MAX(order_date), MIN(order_date)))) AS lifespan
FROM gold.fact_sales f 
LEFT JOIN gold.dim_customers c 
  ON f.customer_key = c.customer_key
GROUP BY c.customer_key 
)
select customer_segment , COUNT(customer_key) as total_customers
from (
select customer_key ,
CASE when lifespan >= 12 and total_spending > 5000 then 'VIP'
     when lifespan >= 12 and total_spending <= 5000 then 'Regular'
	 Else 'New'
END customer_segment 
from customer_spending )
group by customer_segment 
order by total_customers DESC ;

/* Customer Report 
Purpose:
    - This report consolidates key customer metrics and behaviors

Highlights:
    1. Gathers essential fields such as names, ages, and transaction details.
	2. Segments customers into categories (VIP, Regular, New) and age groups.
    3. Aggregates customer-level metrics:
	   - total orders
	   - total sales
	   - total quantity purchased
	   - total products
	   - lifespan (in months)
    4. Calculates valuable KPIs:
	    - recency (months since last order)
		- average order value
		- average monthly spend 
*/ 

CREATE VIEW gold.customers_report AS
WITH base_query AS (
 /* 
 1) Base Query: Retrieves core columns from tables 
 */
 SELECT
 f.order_number,
 f.product_key,
 f.order_date,
 f.sales_amount,
 f.quantity,
 c.customer_key,
 c.customer_number,
 CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
 EXTRACT(YEAR FROM AGE(CURRENT_DATE, c.birthdate)) AS age
 FROM gold.fact_sales f
 LEFT JOIN gold.dim_customers c
 ON c.customer_key = f.customer_key
 WHERE f.order_date IS NOT NULL
),

customer_aggregation AS (
 /* 
 2) Customer Aggregations: Summarizes key metrics at the customer level
 */ 
 SELECT 
 customer_key,
 customer_number,
 customer_name,
 age,
 COUNT(DISTINCT order_number) AS total_orders,
 SUM(sales_amount) AS total_sales,
 SUM(quantity) AS total_quantity,
 COUNT(DISTINCT product_key) AS total_products,
 MAX(order_date) AS last_order_date,
        (
            DATE_PART('year', AGE(MAX(order_date), MIN(order_date))) * 12 +
            DATE_PART('month', AGE(MAX(order_date), MIN(order_date)))
        ) AS lifespan
 FROM base_query 
 GROUP BY 
        customer_key, 
        customer_number, 
        customer_name, 
        age
)

SELECT
    customer_key,
    customer_number,
    customer_name,
    age,
    CASE 
        WHEN age < 20 THEN 'Under 20'
        WHEN age BETWEEN 20 AND 29 THEN '20-29'
        WHEN age BETWEEN 30 AND 39 THEN '30-39'
        WHEN age BETWEEN 40 AND 49 THEN '40-49'
        ELSE '50 and above'
    END AS age_group,
    CASE 
        WHEN lifespan >= 12 AND total_sales > 5000 THEN 'VIP'
        WHEN lifespan >= 12 AND total_sales <= 5000 THEN 'Regular'
        ELSE 'New'
    END AS customer_segment,
    last_order_date,
    (
        DATE_PART('year', AGE(CURRENT_DATE, last_order_date)) * 12 +
        DATE_PART('month', AGE(CURRENT_DATE, last_order_date))
    ) AS recency,
    total_orders,
    total_sales,
    total_quantity,
    total_products,
    lifespan,
    -- Compute average order value (AOV)
    CASE 
        WHEN total_orders = 0 THEN 0
        ELSE ROUND((total_sales / total_orders)::numeric, 2)
    END AS avg_order_value,
    -- Compute average monthly spend
    CASE 
        WHEN lifespan = 0 THEN total_sales
        ELSE ROUND((total_sales / lifespan)::numeric, 2)
    END AS avg_monthly_spend
FROM customer_aggregation;

select * from gold.customers_report ;
